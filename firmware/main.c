 /*
 * MAIN Generated Driver File
 * 
 * @file main.c
 * 
 * @defgroup main MAIN
 * 
 * @brief This is the generated driver implementation file for the MAIN driver.
 *
 * @version MAIN Driver Version 1.0.2
 *
 * @version Package Version: 3.1.2
*/

/*
? [2025] Microc� [2025] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/
#include "mcc_generated_files/system/system.h"
#include "water_meter.h"
#include <xc.h>

/*
    Main application
    
    Water Meter Counter using dual LC tank circuits (CMP1, CMP2)
    with S0 pulse output interface and deep sleep mode.
    
    Pin Assignment:
    - RC5: LC Tank A input (CMP1 comparator)
    - RC0: LC Tank B input (CMP2 comparator)
    - RB2: S0 output (pulse interface, ~100ms pulses)
    
    Power Management:
    - Enters deep sleep mode to minimize power consumption
    - Wakes up every 1.5-2 seconds to check for water meter rotations
    - Q_3 = 2.5 m³/h: Minimum rotation time = 1.44 seconds
    - Safe timeout: 1500ms minimum to ensure no rotations are missed
*/

int main(void)
{
    SYSTEM_Initialize();
    INTERRUPT_GlobalInterruptHighEnable(); 
    INTERRUPT_GlobalInterruptLowEnable(); 
    INTERRUPT_PeripheralInterruptEnable(); 

    // CRITICAL: Force RC5 and RC0 to be DIGITAL OUTPUTS
    // MCC configures them as inputs and regenerates on build
    // Must be IMMEDIATELY after SYSTEM_Initialize() before anything else uses these pins
    TRISCbits.TRISC5 = 0;  // RC5 (LCA) = output
    TRISCbits.TRISC0 = 0;  // RC0 (LCB) = output
    
    // CRITICAL: Ensure RA5 and RB1 (comparator inputs) are in ANALOG mode
    // Comparators REQUIRE analog inputs to work properly!
    // Digital mode uses Schmitt trigger which clips small AC signals
    // ANSELA is at 0xF1C (bit 4 for RA5), ANSELB is at 0xF1D (bit 1 for RB1)
    *(volatile unsigned char*)0xF1C |= 0x10;   // Set bit 4 (RA5) - set to ANALOG mode
    *(volatile unsigned char*)0xF1D |= 0x02;   // Set bit 1 (RB1) - set to ANALOG mode 

    // Initialize water meter counter module
    WaterMeter_Initialize();
    
    // CRITICAL: Force RC5 and RC0 BACK to outputs after WaterMeter_Initialize()
    // WaterMeter_Initialize() calls CMP1/2_Initialize() which may reset pin modes
    TRISCbits.TRISC5 = 0;  // RC5 (LCA) = output
    TRISCbits.TRISC0 = 0;  // RC0 (LCB) = output
    
    // CRITICAL FIX: MCC has a bug where register values aren't set properly
    // Must be AFTER WaterMeter_Initialize() because it calls CMP1/2_Initialize()
    // which would overwrite our register settings
    // CVref: 0xBA = CVREN=1, CVROE=1, CVRSS=0, CVR=10 (generates ~1.72V on RA2)
    // Formula: Vref = (CVR+1)*5/32 = (10+1)*5/32 = 1.72V
    // CVROE=1 enables the output on RA2 so comparators can use it as threshold
    CVRCON = 0xBA;
    
    // Comparators: 0x9C = CNCH=1(C1INB), CPCH=1(CVREF), EVPOL=0, CPOL=0, COE=1, CON=1
    CM1CON = 0x9C;  // Compare C1INB input against CVref
    CM2CON = 0x98;  // Changed from 0x9C - COE=0 to free RC0 for GPIO (was blocking LCB drive)
    
    // Enable sleep mode with safe timeout for Q_3 = 2.5 m³/h
    // 1 liter per 1.44 seconds minimum, use 1500ms safe timeout
    WaterMeter_SetSleepEnabled(true);
    
    // Wait for UART to settle
    __delay_ms(100);
    printf("\r\n=== Water Meter Counter Started ===\r\n");
    printf("Q_3: 2.5 m³/h | S0 Output: RB2\r\n");
    printf("\r\nRunning hardware diagnostic test...\r\n");
    
    // Run diagnostic test to verify LC tank hardware is working
    WaterMeter_DiagnosticTest();

    while(1)
    {
        // Process water meter counter state machine
        // This monitors the LC tank circuits and generates S0 pulses
        if (WaterMeter_Process()) {
            // A full rotation was detected
            // S0 pulse is automatically generated by the module
            printf("\r\nRotation detected. Count: %lu\r\n", WaterMeter_GetRotationCount());
            // Wait for UART transmission to complete before sleeping
            while (!EUSART1_IsTxDone()) {
                __delay_us(10);
            }
        }
        
        // Debug output for LC tank oscillation measurements
        printf("LCA: %3d (metal:%d, thr:%d)  LCB: %3d (metal:%d, thr:%d)  |  CMP1=%d CMP2=%d\r\n", 
               WaterMeter_GetLCA_OscillationCount(),
               WaterMeter_GetLCA_State(),
               18,  /* Calibrated threshold */
               WaterMeter_GetLCB_OscillationCount(),
               WaterMeter_GetLCB_State(),
               18,  /* Calibrated threshold */
               WaterMeter_GetCMP1_Output(),
               WaterMeter_GetCMP2_Output());
        // Wait for UART transmission to complete before sleeping
        while (!EUSART1_IsTxDone()) {
            __delay_us(10);
        }
        
        // Add delay between measurements to prevent continuous polling
        // This gives time for LC tank to fully stabilize and reduces power consumption
        __delay_ms(500);  // 500ms delay between measurements
        
        // Enter deep sleep mode if system is idle
        // Device will wake up every 3 seconds to check for rotations
        // Timeout accounts for: disc geometry (7.5mm radius, 120° offset inductors, half metal)
        if (WaterMeter_CanSleep()) {
            WaterMeter_EnterDeepSleep(3000);  /* 3 second timeout for safety with geometry */
        }
    }    
}